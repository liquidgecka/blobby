package fid

import (
	"encoding/base64"
	"fmt"
	"sync/atomic"
	"time"
)

var fidID uint32

// A unique identifier used to track individual files generated by the storage
// implementation.
//
// FID's are currently comprised of two parts (all big endian):
// 32 bites of a timestamp
// 16 bit globally auto incrementing number.
// 32 bit machine id.
type FID [10]byte

// Parses a full ID string into a FID, start and length values. This will
// automatically account for short and long ID names.
func ParseID(s string) (FID, uint64, uint32, error) {
	raw := [22]byte{}
	start := uint64(0)
	length := uint32(0)
	n, err := base64.RawURLEncoding.Decode(raw[:], []byte(s))
	if err != nil {
		return FID{}, 0, 0, err
	} else if n == 18 {
		// Short
		start = ((uint64(raw[10]) << 24) +
			(uint64(raw[11]) << 16) +
			(uint64(raw[12]) << 8) +
			(uint64(raw[13])))
		length = ((uint32(raw[14]) << 24) +
			(uint32(raw[15]) << 16) +
			(uint32(raw[16]) << 8) +
			(uint32(raw[17])))
	} else if n == 22 {
		// Long
		start = ((uint64(raw[10]) << 56) +
			(uint64(raw[11]) << 48) +
			(uint64(raw[12]) << 40) +
			(uint64(raw[13]) << 32) +
			(uint64(raw[14]) << 24) +
			(uint64(raw[15]) << 16) +
			(uint64(raw[16]) << 8) +
			(uint64(raw[17])))
		length = ((uint32(raw[18]) << 24) +
			(uint32(raw[19]) << 16) +
			(uint32(raw[20]) << 8) +
			(uint32(raw[21])))
	} else {
		return FID{}, 0, 0, fmt.Errorf("Not a valid ID token.")
	}
	f := FID{
		raw[0],
		raw[1],
		raw[2],
		raw[3],
		raw[4],
		raw[5],
		raw[6],
		raw[7],
		raw[8],
		raw[9],
	}
	return f, start, length, nil
}

func (f *FID) String() string {
	return base64.RawURLEncoding.EncodeToString(f[:])
}

// Generates a new file id and populates the values inside of the passed
// FID. This will overwrite any existing data.
func (f *FID) Generate(machID uint32) {
	id := uint16(atomic.AddUint32(&fidID, 1))
	now := time.Now().Unix()
	f[0] = byte((now >> 24) & 0xFF)
	f[1] = byte((now >> 16) & 0xFF)
	f[2] = byte((now >> 8) & 0xFF)
	f[3] = byte((now >> 0) & 0xFF)
	f[4] = byte((id >> 8) & 0xFF)
	f[5] = byte((id >> 0) & 0xFF)
	f[6] = byte((machID >> 24) & 0xFF)
	f[7] = byte((machID >> 16) & 0xFF)
	f[8] = byte((machID >> 8) & 0xFF)
	f[9] = byte((machID >> 0) & 0xFF)
}

// Generates a new unique positional id for an object stored within this
// file.
func (f *FID) ID(start uint64, length uint32) string {
	if start < 1<<32 {
		return f.shortID(start, length)
	} else {
		return f.longID(start, length)
	}
}

// Returns the machine that generated this fid.
func (f *FID) Machine() uint32 {
	return (0 +
		(uint32(f[6]) << 24) +
		(uint32(f[7]) << 16) +
		(uint32(f[8]) << 8) +
		uint32(f[9]))
}

func (f *FID) Parse(s string) error {
	if base64.RawURLEncoding.DecodedLen(len(s)) != len(f) {
		return fmt.Errorf("Invalid FID string.")
	}
	_, err := base64.RawURLEncoding.Decode(f[:], []byte(s))
	if err != nil {
		return err
	} else {
		return nil
	}
}

// Generates a "short" id. These are used when start is less than 4G.
func (f *FID) shortID(start uint64, length uint32) string {
	// The underlying raw data is 24 bytes:
	//  10 bytes for the fid
	//   4 bytes for the start position
	//   4 bytes for the length.
	raw := [18]byte{
		f[0],
		f[1],
		f[2],
		f[3],
		f[4],
		f[5],
		f[6],
		f[7],
		f[8],
		f[9],
		byte((start >> 24) & 0xFF),
		byte((start >> 16) & 0xFF),
		byte((start >> 8) & 0xFF),
		byte((start >> 0) & 0xFF),
		byte((length >> 24) & 0xFF),
		byte((length >> 16) & 0xFF),
		byte((length >> 8) & 0xFF),
		byte((length >> 0) & 0xFF),
	}
	return base64.RawURLEncoding.EncodeToString(raw[:])
}

func (f *FID) longID(start uint64, length uint32) string {
	// The underlying raw data is 24 bytes:
	//  10 bytes for the fid
	//   8 bytes for the start position
	//   4 bytes for the length.
	raw := [22]byte{
		f[0],
		f[1],
		f[2],
		f[3],
		f[4],
		f[5],
		f[6],
		f[7],
		f[8],
		f[9],
		byte((start >> 56) & 0xFF),
		byte((start >> 48) & 0xFF),
		byte((start >> 40) & 0xFF),
		byte((start >> 32) & 0xFF),
		byte((start >> 24) & 0xFF),
		byte((start >> 16) & 0xFF),
		byte((start >> 8) & 0xFF),
		byte((start >> 0) & 0xFF),
		byte((length >> 24) & 0xFF),
		byte((length >> 16) & 0xFF),
		byte((length >> 8) & 0xFF),
		byte((length >> 0) & 0xFF),
	}
	return base64.RawURLEncoding.EncodeToString(raw[:])
}
