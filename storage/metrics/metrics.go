package metrics

import (
	"sync/atomic"
)

// When metrics are requested from a Storage implementation this structure
// will get returned. It contains counters and metrics specific to the
// running Storage implementation.
type Metrics struct {
	// The total number of bytes that have been successfully ingested
	// into Primaries hosted by this storage instance.
	BytesInserted int64

	// Counts of files deleted on disk. This includes primaries and
	// replicas.
	FilesDeleted MetricFailedSuccessTotal

	// We also have a special set of metrics for tracking internally
	// generated and completely unexpected errors. Unlike Insert and
	// replication related metrics, which can return errors in cases
	// where the client has issues (short writes and tcp disconnects being
	// the most likely sources), these metrics track errors that can only
	// be generated by local system failures.
	InternalInsertErrors int64

	// Amount of time the oldest file has been queued for uploading (including
	// the time it takes to actually upload).
	OldestQueuedUpload float64

	// Age of oldest file that has not been uploaded to S3, in seconds:
	OldestUnUploadedData float64

	// Count of primaries that have been deleted.
	PrimaryDeletes MetricFailedSuccessTotal

	// Counts the total number of Insert operations.
	PrimaryInserts MetricFailedSuccessTotal

	// Counts the total number of nanoseconds that requests were queued
	// for before finding a primary file to insert into. This does not
	// include the time it took to actually perform the insert.
	PrimaryInsertQueueNanoseconds uint64

	// Counts the total number of nanoseconds that requests have spent
	// replicating to other instances.
	PrimaryInsertReplicateNanoseconds uint64

	// Counts the total number of nanoseconds that requests have spent
	// writing to local disk.
	PrimaryInsertWriteNanoseconds uint64

	// Counts of the primary open operations.
	PrimaryOpens MetricFailedSuccessTotal

	// Count of primaries that have been uploaded.
	PrimaryUploads MetricFailedSuccessTotal

	// The number of queued inserts.
	QueuedInserts int64

	// A pure count of replicas that have been queued for deleting.
	ReplicaDeletes MetricFailedSuccessTotal

	// Counts of replica HeartBeats
	ReplicaHeartBeats MetricFailedSuccessTotal

	// Counts of replica Initialize requests.
	ReplicaInitializes MetricFailedSuccessTotal

	// A pure count of the number of replicas that have been marked as
	// orphaned and therefor have moved into an uploading state.
	ReplicaOrphaned int64

	// Counts of replica QueueDeletes
	ReplicaQueueDeletes MetricFailedSuccessTotal

	// Counts of replica Replicates
	ReplicaReplicates MetricFailedSuccessTotal

	// Counts of replicas that have been Uploaded.
	ReplicaUploads MetricFailedSuccessTotal
}

func (m *Metrics) CopyFrom(m2 *Metrics) {
	m.BytesInserted = atomic.LoadInt64(&m2.BytesInserted)
	m.FilesDeleted.CopyFrom(&m2.FilesDeleted)
	m.InternalInsertErrors = atomic.LoadInt64(&m2.InternalInsertErrors)
	m.OldestQueuedUpload = m2.OldestQueuedUpload
	m.OldestUnUploadedData = m2.OldestUnUploadedData
	m.PrimaryDeletes.CopyFrom(&m2.PrimaryDeletes)
	m.PrimaryInserts.CopyFrom(&m2.PrimaryInserts)
	m.PrimaryInsertQueueNanoseconds = atomic.LoadUint64(&m2.PrimaryInsertQueueNanoseconds)
	m.PrimaryInsertWriteNanoseconds = atomic.LoadUint64(&m2.PrimaryInsertWriteNanoseconds)
	m.PrimaryInsertReplicateNanoseconds = atomic.LoadUint64(&m2.PrimaryInsertReplicateNanoseconds)
	m.PrimaryOpens.CopyFrom(&m2.PrimaryOpens)
	m.PrimaryUploads.CopyFrom(&m2.PrimaryUploads)
	m.QueuedInserts = atomic.LoadInt64(&m2.QueuedInserts)
	m.ReplicaDeletes.CopyFrom(&m2.ReplicaDeletes)
	m.ReplicaHeartBeats.CopyFrom(&m2.ReplicaHeartBeats)
	m.ReplicaInitializes.CopyFrom(&m2.ReplicaInitializes)
	m.ReplicaOrphaned = atomic.LoadInt64(&m2.ReplicaOrphaned)
	m.ReplicaQueueDeletes.CopyFrom(&m2.ReplicaQueueDeletes)
	m.ReplicaReplicates.CopyFrom(&m2.ReplicaReplicates)
	m.ReplicaUploads.CopyFrom(&m2.ReplicaUploads)
}

// Several metric types have a concept of a counter of total attempts,
// along with successful and error responses.
type MetricFailedSuccessTotal struct {
	Failures  int64
	Successes int64
	Total     int64
}

// Copies the data in the given object into the current object.
func (m *MetricFailedSuccessTotal) CopyFrom(m2 *MetricFailedSuccessTotal) {
	m.Failures = atomic.LoadInt64(&m2.Failures)
	m.Successes = atomic.LoadInt64(&m2.Successes)
	m.Total = atomic.LoadInt64(&m2.Total)
}

func (m *MetricFailedSuccessTotal) IncFailures() {
	atomic.AddInt64(&m.Failures, 1)
}
func (m *MetricFailedSuccessTotal) IncSuccesses() {
	atomic.AddInt64(&m.Successes, 1)
}

func (m *MetricFailedSuccessTotal) IncTotal() {
	atomic.AddInt64(&m.Total, 1)
}
